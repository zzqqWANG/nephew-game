<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>小猫接星星</title>
  <style>
    :root {
      color-scheme: dark;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      margin: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      overscroll-behavior: none;
      font-family: "Segoe UI", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif;
      background: radial-gradient(circle at 50% 20%, #23306b 0%, #10142d 38%, #060812 100%);
    }

    canvas {
      display: block;
      width: 100vw;
      height: 100dvh;
      touch-action: none;
    }

    .overlay {
      position: fixed;
      inset: 0;
      pointer-events: none;
      color: #ffffff;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.4);
    }

    .score {
      position: absolute;
      top: calc(16px + env(safe-area-inset-top));
      left: calc(12px + env(safe-area-inset-left));
      padding: 8px 12px;
      border-radius: 12px;
      font-size: 24px;
      font-weight: 700;
      letter-spacing: 0.5px;
      background: rgba(8, 12, 30, 0.35);
      border: 1px solid rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(4px);
    }

    .title {
      position: absolute;
      top: calc(16px + env(safe-area-inset-top));
      left: 50%;
      transform: translateX(-50%);
      font-size: 18px;
      font-weight: 600;
      opacity: 0.9;
      background: rgba(8, 12, 30, 0.28);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 8px 14px;
      backdrop-filter: blur(4px);
    }

    .center-msg {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      min-width: 280px;
      max-width: 86vw;
      text-align: center;
      padding: 18px 20px;
      border-radius: 16px;
      background: rgba(8, 12, 30, 0.45);
      border: 1px solid rgba(255, 255, 255, 0.18);
      box-shadow: 0 18px 45px rgba(0, 0, 0, 0.35);
      backdrop-filter: blur(6px);
      opacity: 0;
      transition: opacity 220ms ease;
      pointer-events: auto;
      cursor: pointer;
    }

    .center-msg.show {
      opacity: 1;
    }

    .center-msg h2 {
      margin: 0 0 10px;
      font-size: 28px;
      font-weight: 800;
      color: #ffef97;
      text-shadow: 0 0 18px rgba(255, 238, 150, 0.55);
    }

    .center-msg p {
      margin: 6px 0;
      font-size: 15px;
      opacity: 0.95;
      line-height: 1.5;
    }

    .kbd {
      display: inline-block;
      margin: 0 2px;
      padding: 1px 6px;
      font-size: 13px;
      border-radius: 6px;
      background: rgba(255, 255, 255, 0.14);
      border: 1px solid rgba(255, 255, 255, 0.25);
    }

    .touch-controls {
      position: absolute;
      left: 0;
      right: 0;
      bottom: calc(12px + env(safe-area-inset-bottom));
      display: flex;
      justify-content: center;
      gap: 14px;
      pointer-events: none;
    }

    .touch-btn {
      width: 72px;
      height: 72px;
      border-radius: 50%;
      border: 1px solid rgba(255, 255, 255, 0.28);
      background: rgba(10, 16, 36, 0.45);
      color: #ffffff;
      font-size: 34px;
      line-height: 1;
      text-align: center;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(5px);
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.25);
      pointer-events: auto;
      user-select: none;
      -webkit-user-select: none;
      -webkit-tap-highlight-color: transparent;
      touch-action: none;
    }

    .touch-btn:active,
    .touch-btn.active {
      background: rgba(26, 38, 84, 0.65);
      transform: scale(0.98);
    }

    @media (hover: hover) and (pointer: fine) {
      .touch-controls {
        opacity: 0.25;
      }
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>

  <div class="overlay" aria-hidden="true">
    <div class="score" id="score">得分：0</div>
    <div class="title">小猫接星星</div>
    <div class="center-msg show" id="message">
      <h2>准备开始</h2>
      <p>使用 <span class="kbd">←</span> <span class="kbd">→</span> 或下方按钮控制小猫移动，接住掉落的星星。</p>
      <p>按 <span class="kbd">空格</span>/<span class="kbd">Enter</span> 或点击这里开始</p>
    </div>
    <div class="touch-controls" aria-label="触屏控制">
      <button class="touch-btn" id="btnLeft" type="button" aria-label="向左">◀</button>
      <button class="touch-btn" id="btnRight" type="button" aria-label="向右">▶</button>
    </div>
  </div>

  <script>
    class InputController {
      constructor(leftBtn, rightBtn) {
        this.left = false;
        this.right = false;
        this.startPressed = false;

        window.addEventListener("keydown", (event) => {
          if (event.key === "ArrowLeft") this.left = true;
          if (event.key === "ArrowRight") this.right = true;
          if (event.key === " " || event.key === "Enter") this.startPressed = true;
          if (["ArrowLeft", "ArrowRight", " ", "Enter"].includes(event.key)) {
            event.preventDefault();
          }
        });

        window.addEventListener("keyup", (event) => {
          if (event.key === "ArrowLeft") this.left = false;
          if (event.key === "ArrowRight") this.right = false;
        });

        this.bindTouchButton(leftBtn, "left");
        this.bindTouchButton(rightBtn, "right");
      }

      bindTouchButton(button, direction) {
        if (!button) return;

        const setPressed = (pressed) => {
          this[direction] = pressed;
          button.classList.toggle("active", pressed);
        };

        const onDown = (event) => {
          event.preventDefault();
          setPressed(true);
        };

        const onUp = (event) => {
          event.preventDefault();
          setPressed(false);
        };

        button.addEventListener("pointerdown", onDown, { passive: false });
        button.addEventListener("pointerup", onUp, { passive: false });
        button.addEventListener("pointercancel", onUp, { passive: false });
        button.addEventListener("pointerleave", onUp, { passive: false });
      }

      consumeStart() {
        const pressed = this.startPressed;
        this.startPressed = false;
        return pressed;
      }
    }

    class Player {
      constructor(game) {
        this.game = game;
        this.width = 74;
        this.height = 58;
        this.speed = 560;
        this.x = game.width * 0.5 - this.width * 0.5;
        this.y = game.height - this.height - game.bottomPadding;
      }

      reset() {
        this.x = this.game.width * 0.5 - this.width * 0.5;
        this.y = this.game.height - this.height - this.game.bottomPadding;
      }

      update(deltaTime) {
        if (this.game.input.left) this.x -= this.speed * deltaTime;
        if (this.game.input.right) this.x += this.speed * deltaTime;

        if (this.x < 8) this.x = 8;
        const maxX = this.game.width - this.width - 8;
        if (this.x > maxX) this.x = maxX;
      }

      draw(ctx) {
        const centerX = this.x + this.width / 2;
        const centerY = this.y + this.height / 2;

        ctx.save();
        ctx.translate(centerX, centerY);

        const bob = Math.sin(this.game.time * 0.004) * 1.8;
        ctx.translate(0, bob);

        ctx.fillStyle = "rgba(0,0,0,0.2)";
        ctx.beginPath();
        ctx.ellipse(0, this.height * 0.42, 26, 8, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = "#ffbe98";
        ctx.strokeStyle = "#f59c7a";
        ctx.lineWidth = 2;

        ctx.beginPath();
        ctx.roundRect(-24, -14, 48, 35, 16);
        ctx.fill();
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(-18, -9);
        ctx.lineTo(-6, -24);
        ctx.lineTo(-2, -8);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(18, -9);
        ctx.lineTo(6, -24);
        ctx.lineTo(2, -8);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = "#2d2930";
        ctx.beginPath();
        ctx.arc(-9, -2, 2.2, 0, Math.PI * 2);
        ctx.arc(9, -2, 2.2, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = "#2d2930";
        ctx.lineWidth = 1.8;
        ctx.beginPath();
        ctx.moveTo(-4, 6);
        ctx.quadraticCurveTo(0, 10, 4, 6);
        ctx.stroke();

        ctx.strokeStyle = "rgba(45,41,48,0.7)";
        ctx.lineWidth = 1.3;
        ctx.beginPath();
        ctx.moveTo(-24, 2);
        ctx.lineTo(-34, 0);
        ctx.moveTo(-24, 8);
        ctx.lineTo(-35, 10);
        ctx.moveTo(24, 2);
        ctx.lineTo(34, 0);
        ctx.moveTo(24, 8);
        ctx.lineTo(35, 10);
        ctx.stroke();

        ctx.restore();
      }
    }

    class FallingStar {
      constructor(game) {
        this.game = game;
        this.radius = 10 + Math.random() * 8;
        this.reset(true);
      }

      reset(initial = false) {
        this.x = Math.random() * (this.game.width - 40) + 20;
        this.y = initial ? -Math.random() * this.game.height : -30;
        this.speed = 180 + Math.random() * 180 + this.game.score * 3.5;
        this.spin = Math.random() * Math.PI * 2;
        this.spinSpeed = 1.8 + Math.random() * 3;
        this.tail = [];
      }

      update(deltaTime) {
        this.y += this.speed * deltaTime;
        this.spin += this.spinSpeed * deltaTime;

        this.tail.push({ x: this.x, y: this.y });
        if (this.tail.length > 7) this.tail.shift();
      }

      draw(ctx) {
        for (let i = 0; i < this.tail.length; i++) {
          const p = this.tail[i];
          const alpha = (i + 1) / this.tail.length;
          ctx.fillStyle = `rgba(255, 234, 132, ${alpha * 0.25})`;
          ctx.beginPath();
          ctx.arc(p.x, p.y, this.radius * (0.2 + alpha * 0.4), 0, Math.PI * 2);
          ctx.fill();
        }

        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.spin);

        const glow = ctx.createRadialGradient(0, 0, 2, 0, 0, this.radius * 1.7);
        glow.addColorStop(0, "rgba(255, 250, 178, 0.95)");
        glow.addColorStop(0.45, "rgba(255, 223, 107, 0.9)");
        glow.addColorStop(1, "rgba(255, 201, 77, 0)");
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(0, 0, this.radius * 1.7, 0, Math.PI * 2);
        ctx.fill();

        this.drawStarShape(ctx, this.radius, this.radius * 0.45, 5);

        ctx.restore();
      }

      drawStarShape(ctx, outer, inner, points) {
        let rotation = Math.PI / 2 * 3;
        const step = Math.PI / points;

        ctx.beginPath();
        ctx.moveTo(0, -outer);
        for (let i = 0; i < points; i++) {
          ctx.lineTo(Math.cos(rotation) * outer, Math.sin(rotation) * outer);
          rotation += step;
          ctx.lineTo(Math.cos(rotation) * inner, Math.sin(rotation) * inner);
          rotation += step;
        }
        ctx.lineTo(0, -outer);
        ctx.closePath();

        const core = ctx.createLinearGradient(-outer, -outer, outer, outer);
        core.addColorStop(0, "#fffbe4");
        core.addColorStop(0.55, "#ffd66d");
        core.addColorStop(1, "#ffba45");

        ctx.fillStyle = core;
        ctx.strokeStyle = "rgba(255, 255, 255, 0.6)";
        ctx.lineWidth = 1;
        ctx.fill();
        ctx.stroke();
      }
    }

    class BackgroundStars {
      constructor(game, count = 120) {
        this.game = game;
        this.stars = Array.from({ length: count }, () => this.createStar());
      }

      createStar() {
        return {
          x: Math.random() * this.game.width,
          y: Math.random() * this.game.height,
          size: Math.random() * 2 + 0.4,
          twinkle: Math.random() * Math.PI * 2,
          twinkleSpeed: 0.8 + Math.random() * 2,
          drift: (Math.random() - 0.5) * 8
        };
      }

      resize() {
        this.stars.forEach((star) => {
          star.x = Math.random() * this.game.width;
          star.y = Math.random() * this.game.height;
        });
      }

      update(deltaTime) {
        this.stars.forEach((star) => {
          star.twinkle += star.twinkleSpeed * deltaTime;
          star.x += star.drift * deltaTime;

          if (star.x < 0) star.x = this.game.width;
          if (star.x > this.game.width) star.x = 0;
        });
      }

      draw(ctx) {
        this.stars.forEach((star) => {
          const alpha = 0.35 + (Math.sin(star.twinkle) + 1) * 0.325;
          ctx.fillStyle = `rgba(255,255,255,${alpha})`;
          ctx.beginPath();
          ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
          ctx.fill();
        });
      }
    }

    class Game {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext("2d");
        this.width = canvas.width = window.innerWidth;
        this.height = canvas.height = window.innerHeight;
        this.isTouchDevice = window.matchMedia("(pointer: coarse)").matches || "ontouchstart" in window;
        this.bottomPadding = this.isTouchDevice ? 108 : 24;

        this.scoreEl = document.getElementById("score");
        this.messageEl = document.getElementById("message");
        this.leftBtn = document.getElementById("btnLeft");
        this.rightBtn = document.getElementById("btnRight");

        this.input = new InputController(this.leftBtn, this.rightBtn);
        this.player = new Player(this);
        this.backgroundStars = new BackgroundStars(this);
        this.stars = [];

        this.starSpawnTimer = 0;
        this.starSpawnInterval = 0.85;

        this.score = 0;
        this.time = 0;
        this.lastTs = 0;
        this.state = "ready"; // ready | running | over

        this.messageEl.addEventListener("click", () => {
          if (this.state === "ready" || this.state === "over") this.startGame();
        });

        window.addEventListener("resize", () => this.handleResize());
      }

      handleResize() {
        this.width = this.canvas.width = window.innerWidth;
        this.height = this.canvas.height = window.innerHeight;
        this.bottomPadding = this.isTouchDevice ? 108 : 24;
        this.player.y = this.height - this.player.height - this.bottomPadding;
        this.backgroundStars.resize();
      }

      startGame() {
        this.score = 0;
        this.updateScore();

        this.stars = [];
        this.starSpawnTimer = 0;
        this.starSpawnInterval = 0.85;

        this.player.reset();
        this.state = "running";
        this.hideMessage();
      }

      endGame() {
        this.state = "over";
        this.showMessage("游戏结束", `最终得分：${this.score}`, "按 空格/Enter 或点击这里重新开始");
      }

      spawnStar() {
        this.stars.push(new FallingStar(this));
      }

      update(deltaTime) {
        this.time += deltaTime * 1000;

        if (this.state === "ready" || this.state === "over") {
          this.backgroundStars.update(deltaTime);
          if (this.input.consumeStart()) this.startGame();
          return;
        }

        this.backgroundStars.update(deltaTime);
        this.player.update(deltaTime);

        this.starSpawnTimer += deltaTime;
        const dynamicInterval = Math.max(0.34, this.starSpawnInterval - this.score * 0.006);
        if (this.starSpawnTimer >= dynamicInterval) {
          this.starSpawnTimer = 0;
          this.spawnStar();
        }

        for (let i = this.stars.length - 1; i >= 0; i--) {
          const star = this.stars[i];
          star.update(deltaTime);

          if (this.checkCatch(star)) {
            this.stars.splice(i, 1);
            this.score += 1;
            this.updateScore();
            continue;
          }

          if (star.y - star.radius > this.height - 4) {
            this.endGame();
            return;
          }
        }
      }

      checkCatch(star) {
        const catTop = this.player.y;
        const catBottom = this.player.y + this.player.height;
        const catLeft = this.player.x + 5;
        const catRight = this.player.x + this.player.width - 5;

        const verticalTouch = star.y + star.radius >= catTop && star.y - star.radius <= catBottom;
        const horizontalTouch = star.x + star.radius >= catLeft && star.x - star.radius <= catRight;

        return verticalTouch && horizontalTouch;
      }

      drawGround() {
        const ctx = this.ctx;
        const groundY = this.height - 14;

        const grad = ctx.createLinearGradient(0, groundY - 24, 0, this.height);
        grad.addColorStop(0, "rgba(133, 171, 255, 0.03)");
        grad.addColorStop(1, "rgba(121, 173, 255, 0.18)");

        ctx.fillStyle = grad;
        ctx.fillRect(0, groundY - 24, this.width, 30);

        ctx.strokeStyle = "rgba(171, 207, 255, 0.4)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, groundY);
        ctx.lineTo(this.width, groundY);
        ctx.stroke();
      }

      draw() {
        const ctx = this.ctx;
        ctx.clearRect(0, 0, this.width, this.height);

        this.backgroundStars.draw(ctx);
        this.drawGround();

        this.stars.forEach((star) => star.draw(ctx));
        this.player.draw(ctx);
      }

      updateScore() {
        this.scoreEl.textContent = `得分：${this.score}`;
      }

      showMessage(title, line1, line2) {
        this.messageEl.innerHTML = `<h2>${title}</h2><p>${line1}</p><p>${line2}</p>`;
        this.messageEl.classList.add("show");
      }

      hideMessage() {
        this.messageEl.classList.remove("show");
      }

      loop = (timestamp) => {
        if (!this.lastTs) this.lastTs = timestamp;
        const deltaTime = Math.min((timestamp - this.lastTs) / 1000, 0.05);
        this.lastTs = timestamp;

        this.update(deltaTime);
        this.draw();

        requestAnimationFrame(this.loop);
      };

      run() {
        requestAnimationFrame(this.loop);
      }
    }

    if (typeof CanvasRenderingContext2D !== "undefined" && !CanvasRenderingContext2D.prototype.roundRect) {
      CanvasRenderingContext2D.prototype.roundRect = function (x, y, width, height, radius) {
        const r = Math.min(radius, width / 2, height / 2);
        this.beginPath();
        this.moveTo(x + r, y);
        this.arcTo(x + width, y, x + width, y + height, r);
        this.arcTo(x + width, y + height, x, y + height, r);
        this.arcTo(x, y + height, x, y, r);
        this.arcTo(x, y, x + width, y, r);
        this.closePath();
      };
    }

    const game = new Game(document.getElementById("gameCanvas"));
    game.run();
  </script>
</body>
</html>
